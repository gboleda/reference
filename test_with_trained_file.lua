-- preambles

require('nngraph')
require('math')
require('LinearNB') -- for linear mappings without bias

cmd = torch.CmdLine()
-- model file to be read
cmd:option('--model_file','', 'name of file storing trained model generated by main.lua')
-- data files
cmd:option('--word_embedding_file','','word embedding file (with word vectors; first field word, rest of the fields vector values)... must be coherent with representations used at model training!')
cmd:option('--image_embedding_file','','image embedding file (with visual vectors; first field word and image, rest of the fields vector values)... must be coherent with representations used at model training!')
cmd:option('--image_set_size', 0, 'max number of images in a set (must be coherent with max size used at model training!')
cmd:option('--normalize_embeddings',0, 'whether to normalize word and image representations, set to 1 to normalize: must be coherent with choice at model training')
cmd:option('--modifier_mode',0,'if set to 1, we assume protocol files to have colon-delimited modifiers prefixed to RE and each image')
cmd:option('--test_file','','format: one stimulus set per line: first field linguistic referring expression (RE), second field index of the right image for the RE in the image set, rest of the fields image set (n indices of the images in the image dataset')
cmd:option('--test_set_size',10, 'test set size')
-- we need to know the model that was used for training, since this affects
-- oov handling
local mst = {ff_ref=true, max_margin_bl=true, ff_ref_with_summary=true, ff_ref_deviance=true, ff_ref_sim_sum=true, ff_ref_sim_sum_revert=true}
local msg='model, to choose from: '
for k, _ in pairs(mst) do msg = msg .. k .. ', ' end
cmd:option('--model','ff_ref', msg)
-- output file
cmd:option('--output_guesses_file','','if this file is defined, we print to it, as separated space-delimited columns, the index the model returned as its guess for each test item, and the corresponding log probability')
-- other options
cmd:option('--debug',0,'set to 1 to go through code flagged as for debugging')
-- DEPRECATED cmd:option('--deviance_mode',0,'compulsory to set to 1 when applying the model to a file with deviants')
opt = cmd:parse(arg or {})
print(opt)

local output_guesses_file=nil
if opt.output_guesses_file~='' then
   output_guesses_file=opt.output_guesses_file
end

-- other general parameters
-- chunks to read files into
BUFSIZE = 2^23 -- 1MB

-- here, list models that can handle deviance, for appropriate data
-- reading
model_can_handle_deviance=0
if ((opt.model=="ff_ref_with_summary") or 
   (opt.model=="ff_ref_deviance") or
   (opt.model=="ff_ref_sim_sum") or
   (opt.model=="ff_ref_sim_sum_revert")) then
   model_can_handle_deviance=1
end

-- here, list models that need information about number of input
-- images, so that for the other models we can reset the list
-- containing this information and we feed the right data to the
-- various models
model_needs_real_image_count=0
if (opt.model=="ff_ref_sim_sum") then
   model_needs_real_image_count=1
end

print('reading the data processing file')
dofile('data.lua')

print('reading the auxiliary functions')
dofile('other.lua')

print('preparing data')

-- reading word embeddings
word_embeddings,t_input_size=
   load_embeddings(opt.word_embedding_file,opt.normalize_embeddings)
-- reading image embeddings
image_embeddings,v_input_size=
   load_embeddings(opt.image_embedding_file,opt.normalize_embeddings)

-- reading data file
local input_table,index_list,nconfounders_per_sequence,
tuples_start_at,tuples_end_at=
   create_input_structures_from_file(
      opt.test_file,
      opt.test_set_size,
      t_input_size,
      v_input_size,
      opt.image_set_size)

print('reading in the model from file ' .. opt.model_file)
model = torch.load(opt.model_file)

print('computing model prediction on test data')
-- passing all test samples through the trained network
local model_prediction=model:forward(input_table)

local set_size=index_list:size(1)
-- if opt.deviance_mode==1 then
--    print('WARNING: accuracy computation for deviants not available yet')
--    accuracy,individual_model_predictions=model_predictions_for_deviants(set_size,opt.image_set_size,model_prediction,nconfounders_per_sequence)
-- else
-- computing accuracy
accuracy,guessed_item_indices,guessed_item_probs,individual_model_predictions=model_accuracy_and_predictions(opt.model,set_size,opt.image_set_size,model_prediction,index_list,nconfounders_per_sequence)
-- end

print('WARNING: if file contains deviants, accuracy computation will not be reliable')
print('test set accuracy is ' .. accuracy)

--if requested, print guesses, their probs and the overall prob distribution 
--to file
if output_guesses_file then
   local extended_dot_vector = nil
   -- in debug mode, we also return dot vectors and deviance cell (when available)
   if (opt.debug==1) then
      local nodes = model:listModules()[1]['forwardnodes']
      for _,node in ipairs(nodes) do
	 if node.data.annotations.name=='extended_dot_vector' then
	    extended_dot_vector = node.data.module.output
	 end
      end
   end
   print("writing individual model predictions to file " .. output_guesses_file)
   -- if opt.deviance_mode==1 then
   --    -- for deviants, we print the gold label and the dot products for each image
   --    print_model_predictions_to_file_for_deviants(output_guesses_file,index_list,individual_model_predictions)
   -- else
   print_model_predictions_to_file(output_guesses_file,opt.model,guessed_item_indices,guessed_item_probs,individual_model_predictions,extended_dot_vector)
--   end
end
